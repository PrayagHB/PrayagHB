"""
Author: Prayag Bhatt, bhatt59@purdue.edu
Assignment: 12.1 - Code Breakers
Date: 04/21/2024

Description:
    This program is for the game “Code Breakers”, which is a guessing game based on the game Mastermind created in the 1970s. In this game, a random code will be generated by the computer which is between 4 and 6 characters long and only contains the digits 0 through 5 (inclusive). Similarly to Wordle, the player attempts to guess the hidden code and is given clues about how close to the correct code they are.

Contributors:
    Name, login@purdue.edu [repeat for each]

My contributor(s) helped me:
    [ ] understand the assignment expectations without
        telling me how they will approach it.
    [ ] understand different ways to think about a solution
        without helping me plan my solution.
    [ ] think through the meaning of a specific error or
        bug present in my code without looking at my code.
    Note that if you helped somebody else with their code, you
    have to list that person as a contributor.

Academic Integrity Statement:
    I have not used source code obtained from any unauthorized
    source, either modified or unmodified; nor have I provided
    another student access to my code.  The project I am
    submitting is my own original work.
"""

"""Import additional modules below this line (starting with unit 6)."""
import random as r
import datetime

"""Write new functions below this line (starting with unit 4)."""
save_slots = {"1": "empty", "2": "empty", "3": "empty"}
time_stamps = {"1": "", "2": "", "3": ""}

def generate_solution(min_length, max_length):
    length = r.randint(min_length, max_length)
    solution = ""
    for _ in range(length):
        solution += str(r.randint(0, 5))
    return solution

def display_board(solution, guesses, clues, game_over=False):
    if not game_over:
        solution_display = '  '.join(solution.ljust(6, 'o'))  #Fill remaining spaces with 'o's
    else:
        solution_display = '  '.join(solution[:6].ljust(6, 'o'))  #Fill remaining spaces with 'o's if necessary

    print("+------------------+-----+")
    print("|", solution_display, "| R W |")
    print("+------------------+-----+")

    num_guesses = len(guesses)
    num_empty_rows = max(0, 10 - num_guesses)  #To determine the number of empty rows needed

    start_index = max(0, num_guesses - 10)  #To determine the starting index for displaying guesses

    for i in range(num_empty_rows):
        print("| o  o  o  o  o  o | 0 0 |")

    for i in range(start_index + 9, start_index - 1, -1):    #Using reversed range to print guesses in reverse order
        if i >= num_guesses:
            continue
        guess = guesses[i]
        red_pins, white_pins = clues[i]
        guess_display = (guess + 'oo')[:6].ljust(6, 'o')  #For padding with 'o' to ensure 6 digits
        print("|", "  ".join(guess_display), "|", red_pins, white_pins, "|")

    print("+------------------+-----+")

def validate_guess(guess):
    if guess == '':            #space as a short answer message.
        print(f'''Your guess was "{guess}". This is too short.\nGuess lengths must be between 4 and 6.''')
        return False
    if not guess.isdigit():
        print(f'''Your guess was "{guess}". It must be only numbers!''')
        return False
    elif len(guess) < 4:
        print(f'''Your guess was "{guess}". This is too short.\nGuess lengths must be between 4 and 6.''')
        return False
    elif len(guess) > 6:
        print(f'''Your guess was "{guess}". This is too long.\nGuess lengths must be between 4 and 6.''')
        return False
    elif not all(char in '012345' for char in guess):
        print(f'''Your guess was "{guess}". It must be only numbers 0 through 5''')
        return False
    return True

def save_game_menu(save_slots, time_stamps):
    update_save_slots_from_file()
    update_time_stamps_from_file()
    print("Files:")
    for slot, name in save_slots.items():
        if name == "empty":
            print(f" {slot}: empty")
        else:
            print(f" {slot}: {name} - Time: {time_stamps[slot]}")
    
    while True:
        slot_number = input("What save would you like to overwrite (1, 2, 3, or c to cancel): ")
        if slot_number not in ["1", "2", "3",'c']:
            print("That is an invalid selection.")
            continue
        elif slot_number=='c':
            print('cancelled')
            return False
        
        while True:
            slot_name = input("What is your name (no special characters): ")
            if not slot_name.replace(" ", "").isalnum():
                print("That is an invalid name.")
                continue
            
            break 
        
        save_slots[slot_number] = slot_name          #Update the save_slots dictionary with the new name
        
        time_stamps[slot_number] = datetime.datetime.now().isoformat(timespec="seconds")     #Update the time_stamps dictionary with the current timestamp
        
        print(f"Game saved in slot {slot_number} as {slot_name}.\nEnding Game.")
        return slot_name

def play_game(solution, guesses, clues):
    attempts = len(guesses)
    #print(solution) to check the correct answer
    display_board("".join(['o'] * len(solution)), guesses, clues)
    while attempts < 10:
        if attempts == 9:
            guess = input("What is your guess (q to quit, wq to save and quit): ").strip()
            
            if guess == "q" or guess == "Q":
                print("Ending Game.")
                return
            elif guess == "wq":
                slot_name = save_game_menu(save_slots, time_stamps)  #Check if cancelled
                save_slots_to_file(save_slots)
                save_time_stamps_to_file(time_stamps)
                if slot_name:
                    save_game_to_file(slot_name, solution, guesses, clues)
                    return                                            #To retrun to main menu
                else:
                    display_board("".join(['o'] * len(solution)), guesses, clues)
                    continue  #Continue with the game if cancelled
            elif not validate_guess(guess):
                continue
            
            guesses.append(guess)
            red_pins, white_pins = evaluate_guess(solution, guess)
            clues.append((red_pins, white_pins))

            if red_pins == len(solution) and len(guess) == len(solution):
                display_board(solution, guesses, clues, game_over=True)  #Display the unmasked solution
                print("Congratulations, you broke the lock!\nThe grades are safe!")
                return
            
            #display_board("".join(['o'] * len(solution)), guesses, clues) Only change needed for differentiating the last attempt from other attempts
            attempts += 1

        else:
            guess = input("What is your guess (q to quit, wq to save and quit): ").strip()
            
            if guess == "q" or guess == "Q":
                print("Ending Game.")
                return
            elif guess == "wq":
                slot_name = save_game_menu(save_slots, time_stamps)  #Check if cancelled
                save_slots_to_file(save_slots)
                save_time_stamps_to_file(time_stamps)
                if slot_name:
                    save_game_to_file(slot_name, solution, guesses, clues)
                    return                                                #To retrun to main menu
                else:
                    display_board("".join(['o'] * len(solution)), guesses, clues)
                    continue  #Continue with the game if cancelled
            elif not validate_guess(guess):
                continue
            
            guesses.append(guess)
            red_pins, white_pins = evaluate_guess(solution, guess)
            clues.append((red_pins, white_pins))

            if red_pins == len(solution) and len(guess) == len(solution):
                display_board(solution, guesses, clues, game_over=True)  #Display the unmasked solution
                print("Congratulations, you broke the lock!\nThe grades are safe!")
                return
            
            display_board("".join(['o'] * len(solution)), guesses, clues)  #For masking the solution
            attempts += 1

    display_board(solution, guesses, clues, game_over=True)
    print("You hear a machine yell OUT OF TRIES!\n  ...\nIs that burning you smell?\n  ...\nOH, NO! It looks like IU has destroyed all the EBEC grades!\n")

def evaluate_guess(solution, guess):
    red_pins = 0
    white_pins = 0
    solution_d = {}
    guess_d = {}

    for i, digit in enumerate(solution, 1):    #Creates dictionaries for solution and guess
        solution_d[i] = digit
    for i, digit in enumerate(guess, 1):
        guess_d[i] = digit

    for pos in list(solution_d.keys()):       #For counting red pins
        if pos in guess_d and guess_d[pos] == solution_d[pos]:
            red_pins += 1
            del guess_d[pos]
            del solution_d[pos]

    for pos, digit in list(guess_d.items()):  #For counting white pins
        if digit in solution_d.values():
            white_pins += 1
            for key, value in solution_d.items():  #For removing the matching digit from solution_d to avoid double counting
                if value == digit:
                    del solution_d[key]
                    break

    return red_pins, white_pins

def save_game_to_file(slot_name, solution, guesses, clues):
    filename = slot_name + ".txt"
    with open(filename, "w") as file:
        file.write("Solution: " + solution + "\n")   #For writing the solution
        
        for guess, clue in zip(guesses, clues):  #For writing the guesses and clues
             file.write(f"Guess: {guess}  Red Pins: {clue[0]}  White Pins: {clue[1]}\n")       

def load_game_menu(save_slots):
    update_save_slots_from_file()
    update_time_stamps_from_file()
    print("Files:")
    for slot, name in save_slots.items():
        if name == "empty":
            print(f" {slot}: empty")
        else:
            print(f" {slot}: {name} - Time: {time_stamps[slot]}")

    while True:
        slot_number = input("What save would you like to load (1, 2, 3, or c to cancel): ")
        if slot_number not in ["1", "2", "3", 'c']:
            print("That is an invalid selection.")
            continue
        elif slot_number == 'c':
            print('cancelled')
            return False

        slot_name = save_slots[slot_number]
        if slot_name == "empty":
            print("That file is empty!")
            continue

        filename = slot_name + ".txt"
        try:
            with open(filename, "r") as file:
                content = file.readlines()
                solution = content[0].split(": ")[1].strip()   #Print("Loaded solution:", solution) use this to check by putting in next line
                guesses = []
                clues = []
                for line in content[1:]:
                    parts = line.strip().split()
                    #print("Parts:", parts)  #Add this line to check parts
                    if len(parts) >= 7:         #Line contains at least 7 parts because file is saved in such a format
                        guess = parts[1]
                        red_pins = int(parts[4])
                        white_pins = int(parts[7])
                        guesses.append(guess)
                        clues.append((red_pins, white_pins))
                #Print("Loaded guesses:", guesses) for checking the guesses
                #Print("Loaded clues:", clues) for checking the clues
                return solution, guesses, clues  #Returns a tuple with solution, guesses, and clues
        except FileNotFoundError:
            print(f"Error: File '{filename}' not found.")
            return None

def save_slots_to_file(save_slots):
    filename = "slots.txt"
    with open(filename, "w") as file:
        for slot, name in save_slots.items():
            file.write(f"{slot}: {name}\n")

def save_time_stamps_to_file(time_stamps):
    filename = "time.txt"
    with open(filename, "w") as file:
        for slot, time in time_stamps.items():
            file.write(f"{slot}: {time}\n")

def update_save_slots_from_file():
    filename = "slots.txt"
    try:
        with open(filename, "r") as file:
            for line in file:
                slot, name = line.strip().split(": ")
                save_slots[slot] = name
    except FileNotFoundError:
        pass

def update_time_stamps_from_file():
    filename = "time.txt"
    try:
        with open(filename, "r") as file:
            for line in file:
                parts = line.strip().split(": ")
                if len(parts) == 2:
                    slot, time = parts
                    time_stamps[slot] = time
    except FileNotFoundError:
        pass

def main():
    print("You are part of Unladened Swallow Society trying to break the infamous Holy\nGrail lock.  This lock protects a vault where IU has locked up all the EBEC\ngrades.  To get your grades you will have to break this lock.  Luckily\nthose silly IU students messed up when making this lock, and it will give\nyou hints on what the code is.  However, you don't know the length of the\npasscode and only have 10 guesses.  You don't want to run out of these.\nMaybe the vault will turn you into a newt!.  Maybe it will destroy the\ngrades.  What if you have to rewrite time-calculator!\n\nWill you be able to break this lock before your grades are lost forever?\n")
    while True:
        print("Menu:\n  1: Rules\n  2: New Game\n  3: Load Game\n  4: Quit")
        a=str(input("Choice: "))
        if a=='1':
            print("\nCode Breakers Rules:\n1. You get 10 guesses to break the lock.\n2. Guess the correct code to win the game.\n3. Codes can be either 4, 5, or 6 digits in length.\n4. Codes can only contain digits 0, 1, 2, 3, 4, and 5.\n5. Clues for each guess are given by a number of red and white pins.\n   a. The number of red pins in the R column indicates the number of digits\n      in the correct location.\n   b. The number of white pins in the W column indicates the number of\n      digits in the code, but in the wrong location.\n   c. Each digit of the solution code or guess is only counted once in the\n      red or white pins.\n")
        elif a == '2':
            solution = generate_solution(4, 6)
            guesses = []
            clues = []
            play_game(solution, guesses, clues)
        
        elif a == '3':
            loaded_game_state = load_game_menu(save_slots)
            if loaded_game_state:
                solution, guesses, clues = loaded_game_state
                play_game(solution, guesses, clues)
        
        elif a == '4':
            print("Goodbye")
            break
        
        else:
            print("Please enter 1, 2, 3, or 4.")

"""Do not change anything below this line."""
if __name__ == "__main__":
    main()
